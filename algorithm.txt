Input:
vara="* *"
* = Desktop Library
("ech"o $vara'text' | cat && echo *'a') || echo c > file

1. Tokenize
open-bracket 	(
command 		"ech"o $vara'text'
pipe 			|
command 		cat
and				&&
command			echo *'a'
close-bracket	)
or				||
command			echo c
redirection		>
command			file

Why not tokenize by pipelines first?
Because bash will not execute commands unless your pipelines are correct

2. Group
open_bracket	(
pipeline		"ech"o $vara'text' | cat	
			command		"ech"o $vara'text'
			pipe		|
			command		cat
logical_and		&&
pipeline		echo *'a'
			command		echo *'a'
close_bracket	)
logical_or		||
pipeline		echo c > file
			command		echo c
			redirection >
			command		file

3. Parse logic (somehow)
# TODO
# everything that left is evalluating pipelines


4. Expand commands
Input:
vara="* *"
varb=" ' "
* = Desktop Library
"ech"o $vara'text' $varb*"$varb"

4.1. Tokenize braces
dquote		[ech]
normal		[o $vara]
squote		[text]
normal		[ $varb*"$varb"]

4.2. Expand variables
!!! expand only in normal and dquote
dquote		[ech]
normal		[o * *]
squote		[text]
normal		[ ' * ' ]

4.3. Expand wildcards
!!! expand only in normal. do not expand wildcards at the end
example:
echo *" text" -> won't expand
echo *'   text' -> won't expand
echo *123 -> won't expand

dquote		[ech]
normal		[o Desktop Library *]
squote		[text]
normal		[ ' Desktop Library ' ]

4.4. Concatenate
command		echo * *text ' Desktop Library '

4.5. Split by spaces and execute
argv=[echo, *, *text, ', Desktop, Library, ']

5. Evalluate pipelines from left to right

6. Evalluate logic in the order parsed before

1) tokens of type
	type 1: (
	type 2: )
	type 3: && 
	type 4: ||
	type 5: paiplain
2)	Form a data struct from them
3)	Give this DS to an algo that wil execute paiplains in a specific DS-determined order
4)	the aforementioned algo for every pipeline does this:
	5.1) Tokenize cmd to words
	5.2) Parse the list by the rules:
		1)Validate that after every <> comes a WORD
		2)Parse <>, if there's a mistake, complain and terminate current command, but continue the pipe somehow..
		3)
		5.2.0)Parse all <> and get rid of them
		5.2.1)First NOQUOTE_WORD is an executable, all [d][q]words after - args
		5.2.2)