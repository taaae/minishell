Input:
vara="* *"
* = Desktop Library
("ech"o $vara'text' | cat && echo *'a') || echo c > file

1. Tokenize
open-bracket 	(
command 		"ech"o $vara'text'
pipe 			|
command 		cat
and				&&
command			echo *'a'
close-bracket	)
or				||
command			echo c
redirection		>
command			file

Why not tokenize by pipelines first?
Because bash will not execute commands unless your pipelines are correct

2. Group
open_bracket	(
pipeline		"ech"o $vara'text' | cat	
			command		"ech"o $vara'text'
			pipe		|
			command		cat
logical_and		&&
pipeline		echo *'a'
			command		echo *'a'
close_bracket	)
logical_or		||
pipeline		echo c > file
			command		echo c
			redirection >
			command		file

3. Parse logic (somehow)
# TODO
# everything that left is evalluating pipelines


4. Expand commands
Input:
vara="* *"
varb=" ' "
* = Desktop Library
"ech"o $vara'text' $varb*"$varb"

4.1. Tokenize braces
dquote		[ech]
normal		[o $vara]
squote		[text]
normal		[ $varb*"$varb"]

4.2. Expand variables
dquote		[ech]
normal		[o * *]
squote		[text]
normal		[ ' * ' ]

4.3. Expand wildcards
!!! add extra check for wildcards at the end of the string (expand only if the next part is [normal] and have space at the beginning)
example:
a=" 10"
echo *$a -> will expand
echo *"$a" -> won't expand
echo *" 10" -> won't expand

dquote		[ech]
normal		[o Desktop Library *]
squote		[text]
normal		[ ' Desktop Library ' ]

4.4. Concatenate
command		echo * *text ' Desktop Library '

4.5. Split by spaces and execute
argv=[echo, *, *text, ', Desktop, Library, ']

5. Evalluate pipelines from left to right

6. Evalluate logic in the order parsed before
